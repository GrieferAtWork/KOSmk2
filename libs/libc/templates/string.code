/* Copyright (c) 2017 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

/*
 * #define DECL                  ... <declaration visibility/storage>
 * #define DOS_DECL              ... <declaration visibility/storage for dos extension functions>
 * #define DEFINE_ALIAS(new,old) ... <Define `new' as an alias for 'old'>
 * #define T                     ... <character type> (e.g.: `char', `char32_t')
 * #define Tneedle               ... <needle type> (e.g.: `int', `char32_t')
 * #define Ts                    ... <signed type> (e.g.: `signed char', 's32')
 * #define Tu                    ... <unsigned type> (e.g.: `unsigned char', 'u32')
 * #define Tn                    ... <needle type> (e.g.: `int', `char32_t')
 * #define X(x)                  ... <Symbol name generator> (e.g.: `libc_##x', `libc_32w##x') [OPTIONAL] (Used for `libc_splitpath' / `libc_32wsplitpath', etc.)
 * #define Xstr(x)               ... <Symbol name generator> (e.g.: `libc_str##x', `libc_32wcs##x')
 * #define Xstp(x)               ... <Symbol name generator> (e.g.: `libc_stp##x', `libc_32wcp##x')
 * #define Xmb(x)                ... <Symbol name generator> (e.g.: `libc_32mb##x') [OPTIONAL]
 * #define Xwc(x)                ... <Symbol name generator> (e.g.: `libc_32wc##x') [OPTIONAL]
 * #define Xa(x)                 ... <Symbol name generator> (e.g.: `libc_a##x', `libc_32w##x') [OPTIONAL] (Used for `libc_ato32', etc.)
 * #define Xxa(x)                ... <Symbol name generator> (e.g.: `libc_##x##a', `libc_32##x##w') [OPTIONAL] (Used for `libc_s32toa', etc.)
 * #define Xxa_s(x)              ... <Symbol name generator> (e.g.: `libc_##x##a_s', `libc_32##x##w_s') [OPTIONAL] (Used for `libc_s32toa_s', etc.)
 * #define S                     ... <Bit-width in bytes> (e.g.: `__SIZEOF_CHAR__', `__SIZEOF_WCHAR_T__')
 * #define NUL                   ... <\0-character; defaults to ZERO(0)>
 * #define TOLOWER(x)            ... <tolower()-function>
 * #define TOUPPER(x)            ... <toupper()-function>
 * #define TOLOWER_L(x,lc)       ... <locale-dependent tolower()-function>
 * #define TOUPPER_L(x,lc)       ... <locale-dependent toupper()-function>
 * #define DEFINE_ALIAS(new,old) ... <define `new' as an alias of 'old'>
 */ 

/* OPTIONS:
 * WANT_STREND
 * WANT_STRNEND
 * WANT_STRLEN
 * WANT_STRNLEN
 * WANT_STRCHRNUL
 * WANT_STRCHR
 * WANT_STRRCHR
 * WANT_STRRCHRNUL
 * WANT_STRNCHR
 * WANT_STRNRCHR
 * WANT_STRNCHRNUL
 * WANT_STRNRCHRNUL
 * WANT_STROFF
 * WANT_STRROFF
 * WANT_STRNOFF
 * WANT_STRNROFF
 * WANT_STPCPY
 * WANT_STPNCPY
 * WANT_STRCMP
 * WANT_STRNCMP
 * WANT_STRSTR
 * WANT_STRCASESTR
 * WANT_STRCPY
 * WANT_STRNCPY
 * WANT_STRCAT
 * WANT_STRNCAT
 * WANT_STRCSPN
 * WANT_STRSPN
 * WANT_STRPBRK
 * WANT_STRTOK_R
 * WANT_STRTOK
 * WANT_STRFRY
 * WANT_STRLWR
 * WANT_STRLWR_L
 * WANT_STRUPR
 * WANT_STRUPR_L
 * WANT_STRNLWR
 * WANT_STRNLWR_L
 * WANT_STRNUPR
 * WANT_STRNUPR_L
 * WANT_STRSET
 * WANT_STRNSET
 * WANT_STRREV
 * WANT_STRNREV
 * WANT_STRCOLL
 * WANT_STRCOLL_L
 * WANT_STRNCOLL
 * WANT_STRNCOLL_L
 * WANT_STRCASECOLL
 * WANT_STRCASECOLL_L
 * WANT_STRNCASECOLL
 * WANT_STRNCASECOLL_L
 * WANT_STRXFRM
 * WANT_STRXFRM_L
 * WANT_STRCASECMP
 * WANT_STRCASECMP_L
 * WANT_STRNCASECMP
 * WANT_STRNCASECMP_L
 * WANT_STRDUP
 * WANT_STRNDUP
 * WANT_STRCAT_S
 * WANT_STRCPY_S
 * WANT_STRLWR_S
 * WANT_STRLWR_S_L
 * WANT_STRUPR_S
 * WANT_STRUPR_S_L
 * WANT_STRNCAT_S
 * WANT_STRNCPY_S
 * WANT_STRSET_S
 * WANT_STRNSET_S
 * WANT_MBLEN
 * WANT_MBLEN_L
 * WANT_MBTOWC
 * WANT_WCTOMB
 * WANT_WCWIDTH
 * WANT_MBSRTOWCS_S
 * WANT_WCSRTOMBS_S
 * WANT_WCRTOMB_S
 * WANT_STRTOU32
 * WANT_STRTOU64
 * WANT_STRTO32
 * WANT_STRTO64
 * WANT_STRTOU32_L
 * WANT_STRTOU64_L
 * WANT_STRTO32_L
 * WANT_STRTO64_L
 * WANT_ATOF
 * WANT_ATO32
 * WANT_ATO64
 * WANT_ATOF_L
 * WANT_ATO32_L
 * WANT_ATO64_L
 * WANT_STRTOLD
 * WANT_STRTOF
 * WANT_STRTOD
 * WANT_STRTOLD_L
 * WANT_STRTOF_L
 * WANT_STRTOD_L
 * WANT_U32TOA_S
 * WANT_U64TOA_S
 * WANT_S32TOA_S
 * WANT_S64TOA_S
 * WANT_U32TOA
 * WANT_U64TOA
 * WANT_S32TOA
 * WANT_S64TOA
 */
#ifndef NUL
#define NUL 0
#endif

#ifndef TOLOWER_L
#define NO_CASELOCALE
#define TOLOWER_L(x,lc) TOLOWER(x)
#define TOUPPER_L(x,lc) TOUPPER(x)
#endif


#if S == 1
#define STR_MEMPCPY(dst,src,n) ((T *)libc_mempcpy(dst,src,n))
#define STR_MEMCPY(dst,src,n)  ((T *)libc_memcpy(dst,src,n))
#define STR_MEMSET(dst,fill,n) ((T *)libc_memset(dst,fill,n))
#elif S == 2
#define STR_MEMPCPY(dst,src,n) ((T *)libc_mempcpyw(dst,src,n))
#define STR_MEMCPY(dst,src,n)  ((T *)libc_memcpyw(dst,src,n))
#define STR_MEMSET(dst,fill,n) ((T *)libc_memsetw(dst,fill,n))
#elif S == 4
#define STR_MEMPCPY(dst,src,n) ((T *)libc_mempcpyl(dst,src,n))
#define STR_MEMCPY(dst,src,n)  ((T *)libc_memcpyl(dst,src,n))
#define STR_MEMSET(dst,fill,n) ((T *)libc_memsetl(dst,fill,n))
#elif S == 8 && !defined(CONFIG_NO_64BIT_STRING)
#define STR_MEMPCPY(dst,src,n) ((T *)libc_mempcpyq(dst,src,n))
#define STR_MEMCPY(dst,src,n)  ((T *)libc_memcpyq(dst,src,n))
#define STR_MEMSET(dst,fill,n) ((T *)libc_memsetq(dst,fill,n))
#else
#define STR_MEMCPY(dst,src,n)  ((T *)libc_memcpy(dst,src,(n)*S))
#define STR_MEMPCPY(dst,src,n) ((T *)libc_mempcpy(dst,src,(n)*S))
#define STR_MEMSET(dst,fill,n) ((T *)libc_memset(dst,(fill) & 0xff,(n)*S))
#endif

#ifdef WANT_STREND
#undef WANT_STREND
DECL T *LIBCCALL Xstr(end)(T const *__restrict str) {
	for (; *str; ++str);
	return (T *)str;
}
#endif /* WANT_STREND */

#ifdef WANT_STRNEND
#undef WANT_STRNEND
DECL T *LIBCCALL Xstr(nend)
(T const *__restrict str, size_t maxlen) {
	T *end = (T *)str+maxlen;
	for (; str != end && *str; ++str);
	return (T *)str;
}
#endif /* WANT_STRNEND */

#ifdef WANT_STRLEN
#undef WANT_STRLEN
DECL size_t LIBCCALL Xstr(len)
(T const *__restrict str) {
	return (size_t)(Xstr(end)(str)-str);
}
#endif /* WANT_STRLEN */

#ifdef WANT_STRNLEN
#undef WANT_STRNLEN
DECL size_t LIBCCALL Xstr(nlen)
(T const *__restrict str, size_t maxlen) {
	return (size_t)(Xstr(nend)(str,maxlen)-str);
}
#endif /* WANT_STRNLEN */

#ifdef WANT_STRCHRNUL
#undef WANT_STRCHRNUL
DECL T *LIBCCALL Xstr(chrnul)
(T const *__restrict haystack, Tneedle needle) {
	T *iter = (T *)haystack;
	for (; *iter && *iter != (T)needle; ++iter);
	return iter;
}
#endif /* WANT_STRCHRNUL */

#ifdef WANT_STRCHR
#undef WANT_STRCHR
DECL T *LIBCCALL Xstr(chr)
(T const *__restrict haystack, Tneedle needle) {
	T *iter = (T *)haystack;
	for (; *iter != (T)needle; ++iter) if (!*iter) return NULL;
	return iter;
}
#endif /* WANT_STRCHR */

#ifdef WANT_STRRCHR
#undef WANT_STRRCHR
DECL T *LIBCCALL Xstr(rchr)
(T const *__restrict haystack, Tneedle needle) {
	T *result = NULL,*iter = (T *)haystack;
	do if (*iter == (T)needle) result = iter;
	while (*iter++);
	return result;
}
#endif /* WANT_STRRCHR */

#ifdef WANT_STRRCHRNUL
#undef WANT_STRRCHRNUL
DECL T *LIBCCALL Xstr(rchrnul)
(T const *__restrict haystack, Tneedle needle) {
	T *result = (T *)haystack-1,*iter = (T *)haystack;
	do if (*iter == (T)needle) result = iter;
	while (*iter++);
	return result;
}
#endif /* WANT_STRRCHRNUL */

#ifdef WANT_STRNCHR
#undef WANT_STRNCHR
DECL T *LIBCCALL Xstr(nchr)
(T const *__restrict haystack, Tneedle needle, size_t maxlen) {
	T *iter = (T *)haystack,*end = iter+maxlen;
	for (; iter != end && *iter; ++iter) if (*iter == (T)needle) return iter;
	return NULL;
}
#endif /* WANT_STRNCHR */

#ifdef WANT_STRNRCHR
#undef WANT_STRNRCHR
DECL T *LIBCCALL Xstr(nrchr)
(T const *__restrict haystack, Tneedle needle, size_t maxlen) {
	T *iter = (T *)haystack,*end = iter+maxlen,*result = NULL;
	for (; iter != end && *iter; ++iter) if (*iter == (T)needle) result = iter;
	return result;
}
#endif /* WANT_STRNRCHR */

#ifdef WANT_STRNCHRNUL
#undef WANT_STRNCHRNUL
DECL T *LIBCCALL Xstr(nchrnul)
(T const *__restrict haystack, Tneedle needle, size_t maxlen) {
	T *iter = (T *)haystack,*end = iter+maxlen;
	for (; iter != end && *iter && *iter != (T)needle; ++iter);
	return iter;
}
#endif /* WANT_STRNCHRNUL */

#ifdef WANT_STRNRCHRNUL
#undef WANT_STRNRCHRNUL
DECL T *LIBCCALL Xstr(nrchrnul)
(T const *__restrict haystack, Tneedle needle, size_t maxlen) {
	T *iter = (T *)haystack,*end = iter+maxlen,*result = (T *)haystack-1;
	for (; iter != end && *iter; ++iter) if (*iter == (T)needle) result = iter;
	return result;
}
#endif /* WANT_STRNRCHRNUL */

#ifdef WANT_STROFF
#undef WANT_STROFF
DECL size_t LIBCCALL Xstr(off)
(T const *__restrict haystack, Tneedle needle) {
	return (size_t)(Xstr(chrnul)(haystack,needle)-haystack);
}
#endif /* WANT_STROFF */

#ifdef WANT_STRROFF
#undef WANT_STRROFF
DECL size_t LIBCCALL Xstr(roff)
(T const *__restrict haystack, Tneedle needle) {
	return (size_t)(Xstr(rchrnul)(haystack,needle)-haystack);
}
#endif /* WANT_STRROFF */

#ifdef WANT_STRNOFF
#undef WANT_STRNOFF
DECL size_t LIBCCALL Xstr(noff)
(T const *__restrict haystack, Tneedle needle, size_t maxlen) {
	return (size_t)(Xstr(nchrnul)(haystack,needle,maxlen)-haystack);
}
#endif /* WANT_STRNOFF */

#ifdef WANT_STRNROFF
#undef WANT_STRNROFF
DECL size_t LIBCCALL Xstr(nroff)
(T const *__restrict haystack, Tneedle needle, size_t maxlen) {
	return Xstr(nrchrnul)(haystack,needle,maxlen)-haystack;
}
#endif /* WANT_STRNROFF */

#ifdef WANT_STPCPY
#undef WANT_STPCPY
DECL T *LIBCCALL Xstp(cpy)
(T *__restrict dst, T const *__restrict src) {
	return STR_MEMPCPY(dst,src,Xstr(len)(src)+1)-1;
}
#endif /* WANT_STPCPY */

#ifdef WANT_STPNCPY
#undef WANT_STPNCPY
DECL T *LIBCCALL Xstp(ncpy)
(T *__restrict dst, T const *__restrict src, size_t n) {
	size_t src_len = Xstr(nlen)(src,n);
	STR_MEMCPY(dst,src,src_len);
	STR_MEMSET(dst+src_len,NUL,n-src_len);
	return dst+src_len;
}
#endif /* WANT_STPNCPY */

#ifdef WANT_STRCMP
#undef WANT_STRCMP
DECL int LIBCCALL Xstr(cmp)(T const *s1, T const *s2) {
	T a,b; int result;
	do {
		a = *s1++,b = *s2++,
		result = (int)a-(int)b;
	} while (result == 0 && a);
	return result;
}
#endif /* WANT_STRCMP */

#ifdef WANT_STRNCMP
#undef WANT_STRNCMP
DECL int LIBCCALL Xstr(ncmp)(T const *s1, T const *s2, size_t n) {
 T a,b,*end = (T *)s1+n; int result;
 if (n) {
	do {
		a = *s1++,b = *s2++,
		result = (int)a-(int)b;
	} while (result == 0 && a && s1 != end);
 }
 return result;
}
#endif /* WANT_STRNCMP */

#ifdef WANT_STRSTR
#undef WANT_STRSTR
DECL T *LIBCCALL Xstr(str)
(T const *haystack, T const *needle) {
	T *hay_iter = (assert(haystack),(T *)haystack),*hay2;
	T ch,needle_start = (assert(needle),*needle++);
	T const *ned_iter;
	while ((ch = *hay_iter++) != NUL) {
		if (ch == needle_start) {
			hay2 = hay_iter,ned_iter = needle;
			while ((ch = *ned_iter++) != NUL) {
				if (*hay2++ != ch) goto miss;
			}
			return hay_iter-1;
		}
miss:;
	}
	return NULL;
}
#endif /* WANT_STRSTR */


#ifdef WANT_STRCASESTR
#undef WANT_STRCASESTR
DECL T *LIBCCALL Xstr(casestr)(T const *haystack, T const *needle) {
	T *hay_iter = (assert(haystack),(T *)haystack),*hay2;
	T ch,needle_start = (assert(needle),*needle++);
	T const *ned_iter;
	while ((ch = *hay_iter++) != NUL) {
		if (ch == needle_start) {
			hay2 = hay_iter,ned_iter = needle;
			while ((ch = *ned_iter++) != NUL) {
				if (TOLOWER(*hay2++) != TOLOWER(ch))
					goto miss;
			}
			return hay_iter-1;
		}
miss:;
	}
	return NULL;
}
#endif /* WANT_STRCASESTR */


#ifdef WANT_STRCPY
#undef WANT_STRCPY
DECL T *LIBCCALL Xstr(cpy)
(T *__restrict dst, T const *__restrict src) {
	return STR_MEMCPY(dst,src,Xstr(len)(src)+1);
}
#endif /* WANT_STRCPY */

#ifdef WANT_STRNCPY
#undef WANT_STRNCPY
DECL T *LIBCCALL Xstr(ncpy)
(T *__restrict dst, T const *__restrict src, size_t n) {
	size_t src_len = Xstr(nlen)(src,n);
	STR_MEMCPY(dst,src,src_len);
	STR_MEMSET(dst+src_len,NUL,n-src_len);
	return dst;
}
#endif /* WANT_STRNCPY */

#ifdef WANT_STRCAT
#undef WANT_STRCAT
DECL T *LIBCCALL Xstr(cat)(T *__restrict dst, T const *__restrict src) {
	STR_MEMCPY(Xstr(end)(dst),src,Xstr(len)(src)+1);
	return dst;
}
#endif /* WANT_STRCAT */

#ifdef WANT_STRNCAT
#undef WANT_STRNCAT
DECL T *LIBCCALL Xstr(ncat)(T *__restrict dst, T const *__restrict src, size_t n) {
	size_t src_len = Xstr(nlen)(src,n);
	T *target = Xstr(end)(dst);
	STR_MEMCPY(target,src,src_len);
	target[src_len] = NUL;
	return dst;
}
#endif /* WANT_STRNCAT */

#ifdef WANT_STRCSPN
#undef WANT_STRCSPN
DECL size_t LIBCCALL Xstr(cspn)(T const *s, T const *reject) {
	T const *iter = s;
	while (*iter && !Xstr(chr)(reject,*iter)) ++iter;
	return (size_t)(iter-s);
}
#endif /* WANT_STRCSPN */

#ifdef WANT_STRSPN
#undef WANT_STRSPN
DECL size_t LIBCCALL Xstr(spn)(T const *s, T const *accept) {
	T const *iter = s;
	while (Xstr(chr)(accept,*iter)) ++iter;
	return (size_t)(iter-s);
}
#endif /* WANT_STRSPN */

#ifdef WANT_STRPBRK
#undef WANT_STRPBRK
DECL T *LIBCCALL Xstr(pbrk)(T const *s, T const *accept) {
	T *hay_iter = (T *)s,haych,ch;
	T const *ned_iter;
	while ((haych = *hay_iter++) != NUL) {
		ned_iter = accept;
		while ((ch = *ned_iter++) != NUL) {
			if (haych == ch) return hay_iter-1;
		}
	}
	return NULL;
}
#endif /* WANT_STRPBRK */

#ifdef WANT_STRTOK_R
#undef WANT_STRTOK_R
DECL T *LIBCCALL Xstr(tok_r)
(T *__restrict s, T const *__restrict delim, T **__restrict save_ptr) {
	T *end;
	if (!s) s = *save_ptr;
	if (!*s) { *save_ptr = s; return NULL; }
	s += Xstr(spn)(s,delim);
	if (!*s) { *save_ptr = s; return NULL; }
	end = s+Xstr(cspn)(s,delim);
	if (!*end) { *save_ptr = end; return s; }
	*end = NUL;
	*save_ptr = end+1;
	return s;
}
#endif /* WANT_STRTOK_R */

#ifdef WANT_STRTOK
#undef WANT_STRTOK
#ifndef __strtok_safe_defined
#define __strtok_safe_defined 1
PRIVATE void *strtok_safe = NULL;
#endif /* !__strtok_safe_defined */
DECL T *LIBCCALL Xstr(tok)(T *__restrict s, T const *__restrict delim) {
	return Xstr(tok_r)(s,delim,(T **)&strtok_safe);
}
#endif /* WANT_STRTOK */


#ifdef WANT_STRFRY
#undef WANT_STRFRY
DECL T *LIBCCALL Xstr(fry)(T *string) {
	NOT_IMPLEMENTED();
	return string;
}
#endif /* WANT_STRFRY */


#ifdef WANT_STRLWR
#undef WANT_STRLWR
DECL T *LIBCCALL Xstr(lwr)(T *str) {
	T *result = str;
	for (; *str; ++str)
		*str = TOLOWER(*str);
	return result;
}
#endif /* WANT_STRLWR */
#ifdef WANT_STRLWR_L
#undef WANT_STRLWR_L
#ifdef NO_CASELOCALE
#ifdef CONFIG_LIBCCALL_HAS_CALLER_ARGUMENT_CLEANUP
DEFINE_ALIAS(Xstr(lwr_l),Xstr(lwr));
#else
DECL T *LIBCCALL Xstr(lwr_l)(T *str, locale_t UNUSED(lc)) { return Xstr(lwr)(str); }
#endif
#else /* NO_CASELOCALE */
DECL T *LIBCCALL Xstr(lwr_l)(T *str, locale_t lc) {
	T *result = str;
	for (; *str; ++str)
		*str = TOLOWER_L(*str,lc);
	return result;
}
#endif /* !NO_CASELOCALE */
#endif /* WANT_STRLWR_L */


#ifdef WANT_STRUPR
#undef WANT_STRUPR
DECL T *LIBCCALL Xstr(upr)(T *str) {
	T *result = str;
	for (; *str; ++str)
		*str = TOUPPER(*str);
	return result;
}
#endif /* WANT_STRUPR */
#ifdef WANT_STRUPR_L
#undef WANT_STRUPR_L
#ifdef NO_CASELOCALE
#ifdef CONFIG_LIBCCALL_HAS_CALLER_ARGUMENT_CLEANUP
DEFINE_ALIAS(Xstr(upr_l),Xstr(upr));
#else
DECL T *LIBCCALL Xstr(upr_l)(T *str, locale_t UNUSED(lc)) { return Xstr(upr)(str); }
#endif
#else /* NO_CASELOCALE */
DECL T *LIBCCALL Xstr(upr_l)(T *str, locale_t lc) {
	T *result = str;
	for (; *str; ++str)
		*str = TOUPPER_L(*str,lc);
	return result;
}
#endif /* !NO_CASELOCALE */
#endif /* WANT_STRUPR_L */


#ifdef WANT_STRNLWR
#undef WANT_STRNLWR
DECL T *LIBCCALL Xstr(nlwr)(T *str, size_t maxlen) {
	T *result = str,*end = str+maxlen;
	for (; str != end && *str; ++str)
		*str = TOLOWER(*str);
	return result;
}
#endif /* WANT_STRNLWR */
#ifdef WANT_STRNLWR_L
#undef WANT_STRNLWR_L
#ifdef NO_CASELOCALE
#ifdef CONFIG_LIBCCALL_HAS_CALLER_ARGUMENT_CLEANUP
DEFINE_ALIAS(Xstr(nlwr_l),Xstr(nlwr));
#else
DECL T *LIBCCALL Xstr(nlwr_l)(T *str, size_t maxlen, locale_t UNUSED(lc)) { return Xstr(nlwr)(str,maxlen); }
#endif
#else /* NO_CASELOCALE */
DECL T *LIBCCALL Xstr(nlwr_l)(T *str, size_t maxlen, locale_t lc) {
	T *result = str,*end = str+maxlen;
	for (; str != end && *str; ++str)
		*str = TOLOWER_L(*str,lc);
	return result;
}
#endif /* !NO_CASELOCALE */
#endif /* WANT_STRNLWR_L */


#ifdef WANT_STRNUPR
#undef WANT_STRNUPR
DECL T *LIBCCALL Xstr(nupr)(T *str, size_t maxlen) {
	T *result = str,*end = str+maxlen;
	for (; str != end && *str; ++str)
		*str = TOUPPER(*str);
	return result;
}
#endif /* WANT_STRNUPR */
#ifdef WANT_STRNUPR_L
#undef WANT_STRNUPR_L
#ifdef NO_CASELOCALE
#ifdef CONFIG_LIBCCALL_HAS_CALLER_ARGUMENT_CLEANUP
DEFINE_ALIAS(Xstr(nupr_l),Xstr(nupr));
#else
DECL T *LIBCCALL Xstr(nupr_l)(T *str, size_t maxlen, locale_t UNUSED(lc)) { return Xstr(nupr)(str,maxlen); }
#endif
#else /* NO_CASELOCALE */
DECL T *LIBCCALL Xstr(nupr_l)(T *str, size_t maxlen, locale_t lc) {
	T *result = str,*end = str+maxlen;
	for (; str != end && *str; ++str)
		*str = TOUPPER_L(*str,lc);
	return result;
}
#endif /* !NO_CASELOCALE */
#endif /* WANT_STRNUPR_L */


#ifdef WANT_STRSET
#undef WANT_STRSET
DECL T *LIBCCALL Xstr(set)(T *str, Tneedle chr) {
	T *result = str;
	while (*str) *str++ = (T)chr;
	return result;
}
#endif /* WANT_STRSET */
#ifdef WANT_STRNSET
#undef WANT_STRNSET
DECL T *LIBCCALL Xstr(nset)(T *str, Tneedle chr, size_t maxlen) {
	T *result = str,*end = str+maxlen;
	while (str != end && *str) *str++ = (T)chr;
	return result;
}
#endif /* WANT_STRNSET */


#ifdef WANT_STRREV
#undef WANT_STRREV
DECL T *LIBCCALL Xstr(rev)(T *str) {
	NOT_IMPLEMENTED();
	return str;
}
#endif /* WANT_STRREV */
#ifdef WANT_STRNREV
#undef WANT_STRNREV
DECL T *LIBCCALL Xstr(nrev)(T *str, size_t maxlen) {
	NOT_IMPLEMENTED();
	return str;
}
#endif /* WANT_STRNREV */


#ifdef WANT_STRCOLL
#undef WANT_STRCOLL
DECL int LIBCCALL Xstr(coll)(T const *s1, T const *s2) {
	NOT_IMPLEMENTED();
	return 0;
}
#endif /* WANT_STRCOLL */
#ifdef WANT_STRCOLL_L
#undef WANT_STRCOLL_L
DECL int LIBCCALL Xstr(coll_l)(T const *s1, T const *s2, locale_t l) {
	NOT_IMPLEMENTED();
	return Xstr(coll)(s1,s2);
}
#endif /* WANT_STRCOLL_L */


#ifdef WANT_STRNCOLL
#undef WANT_STRNCOLL
DECL int LIBCCALL Xstr(ncoll)(T const *str1, T const *str2, size_t maxlen) {
	NOT_IMPLEMENTED();
	return 0;
}
#endif /* WANT_STRNCOLL */
#ifdef WANT_STRNCOLL_L
#undef WANT_STRNCOLL_L
DECL int LIBCCALL Xstr(ncoll_l)(T const *str1, T const *str2, size_t maxlen, locale_t lc) {
	NOT_IMPLEMENTED();
	return Xstr(ncoll)(str1,str2,maxlen);
}
#endif /* WANT_STRNCOLL_L */


#ifdef WANT_STRCASECOLL
#undef WANT_STRCASECOLL
DECL int LIBCCALL Xstr(casecoll)(T const *str1, T const *str2) {
	NOT_IMPLEMENTED();
	return 0;
}
#endif /* WANT_STRCASECOLL */
#ifdef WANT_STRCASECOLL_L
#undef WANT_STRCASECOLL_L
DECL int LIBCCALL Xstr(casecoll_l)(T const *str1, T const *str2, locale_t lc) {
	NOT_IMPLEMENTED();
	return Xstr(casecoll)(str1,str2);
}
#endif /* WANT_STRCASECOLL_L */


#ifdef WANT_STRNCASECOLL
#undef WANT_STRNCASECOLL
DECL int LIBCCALL Xstr(ncasecoll)(T const *str1, T const *str2, size_t maxlen) {
	NOT_IMPLEMENTED();
	return 0;
}
#endif /* WANT_STRNCASECOLL */
#ifdef WANT_STRNCASECOLL_L
#undef WANT_STRNCASECOLL_L
DECL int LIBCCALL Xstr(ncasecoll_l)(T const *str1, T const *str2, size_t maxlen, locale_t lc) {
	NOT_IMPLEMENTED();
	return Xstr(ncasecoll)(str1,str2,maxlen);
}
#endif /* WANT_STRNCASECOLL_L */


#ifdef WANT_STRXFRM
#undef WANT_STRXFRM
DECL size_t LIBCCALL Xstr(xfrm)(T *__restrict dst, T const *__restrict src, size_t n) {
	NOT_IMPLEMENTED();
	return 0;
}
#endif /* WANT_STRXFRM */
#ifdef WANT_STRXFRM_L
#undef WANT_STRXFRM_L
DECL size_t LIBCCALL Xstr(xfrm_l)(T *dst, T const *src, size_t n, locale_t l) {
	NOT_IMPLEMENTED();
	return Xstr(xfrm)(dst,src,n);
}
#endif /* WANT_STRXFRM_L */


#ifdef WANT_STRCASECMP
#undef WANT_STRCASECMP
DECL int LIBCCALL Xstr(casecmp)(T const *s1, T const *s2) {
	T a,b; int result;
	do {
		a = TOLOWER(*s1++);
		b = TOLOWER(*s2++);
		result = (int)a-(int)b;
	} while (result == 0 && a);
	return result;
}
#endif /* WANT_STRCASECMP */
#ifdef WANT_STRCASECMP_L
#undef WANT_STRCASECMP_L
#ifdef NO_CASELOCALE
#ifdef CONFIG_LIBCCALL_HAS_CALLER_ARGUMENT_CLEANUP
DEFINE_ALIAS(Xstr(casecmp_l),Xstr(casecmp));
#else
DECL int LIBCCALL Xstr(casecmp_l)(T const *s1, T const *s2, locale_t UNUSED(loc)) { return Xstr(casecmp)(s1,s2); }
#endif
#else /* NO_CASELOCALE */
DECL int LIBCCALL Xstr(casecmp_l)(T const *s1, T const *s2, locale_t loc) {
	T a,b; int result;
	do {
		a = TOLOWER_L(*s1++,loc);
		b = TOLOWER_L(*s2++,loc);
		result = (int)a-(int)b;
	} while (result == 0 && a);
	return result;
}
#endif /* !NO_CASELOCALE */
#endif /* WANT_STRCASECMP_L */


#ifdef WANT_STRNCASECMP
#undef WANT_STRNCASECMP
DECL int LIBCCALL Xstr(ncasecmp)(T const *s1, T const *s2, size_t n) {
	T a,b,*end = (T *)s1+n; int result;
	if (n) {
		do {
			a = TOLOWER(*s1++);
			b = TOLOWER(*s2++);
			result = (int)a-(int)b;
		} while (result == 0 && a && s1 != end);
	}
	return result;
}
#endif /* WANT_STRNCASECMP */
#ifdef WANT_STRNCASECMP_L
#undef WANT_STRNCASECMP_L
#ifdef NO_CASELOCALE
#ifdef CONFIG_LIBCCALL_HAS_CALLER_ARGUMENT_CLEANUP
DEFINE_ALIAS(Xstr(ncasecmp_l),Xstr(ncasecmp));
#else
DECL int LIBCCALL Xstr(ncasecmp_l)(T const *s1, T const *s2, size_t n, locale_t UNUSED(loc)) { return Xstr(ncasecmp)(s1,s2,n); }
#endif
#else /* NO_CASELOCALE */
DECL int LIBCCALL Xstr(ncasecmp_l)(T const *s1, T const *s2, size_t n, locale_t loc) {
	T a,b,*end = (T *)s1+n; int result;
	if (n) {
		do {
			a = TOLOWER_L(*s1++,loc);
			b = TOLOWER_L(*s2++,loc);
			result = (int)a-(int)b;
		} while (result == 0 && a && s1 != end);
	}
	return result;
}
#endif /* !NO_CASELOCALE */
#endif /* WANT_STRNCASECMP_L */


#ifdef WANT_STRDUP
#undef WANT_STRDUP
DECL T *LIBCCALL Xstr(dup)(T const *__restrict str) {
	return (T *)libc_memdup(str,Xstr(len)(str)*S);
}
#endif /* WANT_STRDUP */
#ifdef WANT_STRNDUP
#undef WANT_STRNDUP
DECL T *LIBCCALL Xstr(ndup)(T const *__restrict str, size_t maxlen) {
	return (T *)libc_memdup(str,Xstr(nlen)(str,maxlen)*S);
}
#endif /* WANT_STRNDUP */




/* DOS-SLIB functions. */
#ifdef WANT_STRCAT_S
#undef WANT_STRCAT_S
DECL errno_t LIBCCALL Xstr(cat_s)(T *__restrict dst, size_t dstsize, T const *__restrict src) {
	T *dstend = Xstr(nend)(dst,dstsize);
	size_t srclen = Xstr(len)(src);
	dstsize -= (size_t)(dstend-dst);
	if (srclen+1 > dstsize) return ERANGE;
	STR_MEMCPY(dstend,src,srclen+1);
	return EOK;
}
#endif /* WANT_STRCAT_S */

#ifdef WANT_STRCPY_S
#undef WANT_STRCPY_S
DECL errno_t LIBCCALL Xstr(cpy_s)(T *__restrict dst, size_t dstsize, T const *__restrict src) {
	size_t srclen = Xstr(len)(src);
	if (srclen+1 > dstsize) return ERANGE;
	STR_MEMCPY(dst,src,srclen+1);
	return EOK;
}
#endif /* WANT_STRCPY_S */

#ifdef WANT_STRLWR_S
#undef WANT_STRLWR_S
DECL errno_t LIBCCALL Xstr(lwr_s)(T *__restrict str, size_t buflen) {
	if (Xstr(nlen)(str,buflen) == buflen)
		return ERANGE;
	Xstr(lwr)(str);
	return EOK;
}
#endif /* WANT_STRLWR_S */

#ifdef WANT_STRLWR_S_L
#undef WANT_STRLWR_S_L
DECL errno_t LIBCCALL Xstr(lwr_s_l)(T *__restrict str, size_t buflen, locale_t locale) {
	if (Xstr(nlen)(str,buflen) == buflen)
		return ERANGE;
	Xstr(lwr_l)(str,locale);
	return EOK;
}
#endif /* WANT_STRLWR_S_L */

#ifdef WANT_STRUPR_S
#undef WANT_STRUPR_S
DECL errno_t LIBCCALL Xstr(upr_s)(T *__restrict str, size_t buflen) {
	if (Xstr(nlen)(str,buflen) == buflen)
		return ERANGE;
	Xstr(upr)(str);
	return EOK;
}
#endif /* WANT_STRUPR_S */

#ifdef WANT_STRUPR_S_L
#undef WANT_STRUPR_S_L
DECL errno_t LIBCCALL Xstr(upr_s_l)(T *__restrict str, size_t buflen, locale_t locale) {
	if (Xstr(nlen)(str,buflen) == buflen)
		return ERANGE;
	Xstr(upr_l)(str,locale);
	return EOK;
}
#endif /* WANT_STRUPR_S_L */

#ifdef WANT_STRNCAT_S
#undef WANT_STRNCAT_S
DECL errno_t LIBCCALL Xstr(ncat_s)(T *__restrict dst, size_t dstsize, T const *__restrict src, size_t maxlen) {
	T *dstend = Xstr(nend)(dst,dstsize);
	size_t srclen = Xstr(nlen)(src,maxlen);
	dstsize -= (size_t)(dstend-dst);
	if (srclen+1 > dstsize) return ERANGE;
	STR_MEMCPY(dstend,src,srclen);
	dstend[srclen] = NUL;
	return EOK;
}
#endif /* WANT_STRNCAT_S */

#ifdef WANT_STRNCPY_S
#undef WANT_STRNCPY_S
DECL errno_t LIBCCALL Xstr(ncpy_s)(T *__restrict dst, size_t dstsize, T const *__restrict src, size_t maxlen) {
	size_t srclen = Xstr(nlen)(src,maxlen);
	if (srclen+1 > dstsize) return ERANGE;
	STR_MEMCPY(dst,src,srclen);
	dst[srclen] = NUL;
	return EOK;
}
#endif /* WANT_STRNCPY_S */

#ifdef WANT_STRSET_S
#undef WANT_STRSET_S
DECL errno_t LIBCCALL Xstr(set_s)(T *__restrict str, size_t buflen, T val) {
	if (Xstr(nlen)(str,buflen) == buflen)
		return ERANGE;
	Xstr(set)(str,val);
	return EOK;
}
#endif /* WANT_STRSET_S */

#ifdef WANT_STRNSET_S
#undef WANT_STRNSET_S
DECL errno_t LIBCCALL Xstr(nset_s)(T *__restrict str, size_t buflen, T val, size_t maxlen) {
	/* XXX: How is this supposed to fail? */
	STR_MEMSET(str,val,Xstr(nlen)(str,MIN(buflen,maxlen)));
	return EOK;
}
#endif /* WANT_STRNSET_S */











/* Wide-string UTF conversion functions. */
#if S == 4
#define UTFXTO8  libc_utf32to8
#define UTF8TOX  libc_utf8to32
#elif S == 2
#define UTFXTO8  libc_utf16to8
#define UTF8TOX  libc_utf8to16
#endif

#ifdef WANT_MBLEN
#undef WANT_MBLEN
DECL size_t LIBCCALL Xmb(rlen)
(char const *__restrict s, size_t n, struct __mbstate *__restrict ps) {
	if (!s) { mbstate_reset(ps); return 0; }
	return (ssize_t)UTF8TOX(s,n,NULL,0,ps,
	                        UNICODE_F_STOPONNUL|
	                        UNICODE_F_NOZEROTERM);
}

#ifndef __mblen_state_defined
#define __mblen_state_defined 1
PRIVATE mbstate_t mblen_state = MBSTATE_INIT;
#endif /* !__mblen_state_defined */

DECL size_t LIBCCALL Xmb(len)(char const *s, size_t n) {
	return Xmb(rlen)(s,n,&mblen_state);
}
#endif /* WANT_MBLEN */

#ifdef WANT_MBLEN_L
#undef WANT_MBLEN_L
#ifdef CONFIG_LIBCCALL_HAS_CALLER_ARGUMENT_CLEANUP
DEFINE_ALIAS(Xmb(len_l),Xmb(len));
#else
DECL size_t LIBCCALL Xmb(len_l)
(char const *__restrict s, size_t n, locale_t UNUSED(locale)) {
	return Xmb(len)(s,n);
}
#endif
#endif /* WANT_MBLEN */



#ifdef WANT_MBTOWC
#undef WANT_MBTOWC
DECL size_t LIBCCALL Xmb(rtowc)
(T *__restrict pwc, char const *__restrict s, size_t n, struct __mbstate *__restrict ps) {
	size_t result; char const *start = s;
	if (!s) { mbstate_reset(ps); return 0; }
	result = UTF8TOX((char const *)&s,(size_t)&n,pwc,pwc ? 1 : 0,ps,
	                  UNICODE_F_NOZEROTERM|UNICODE_F_STOPONNUL|
	                  UNICODE_F_UTF16HALF|UNICODE_F_DOSINGLE);
	if (result == UNICODE_ERROR) return -1;
	return (ssize_t)(s-start);
}

#ifndef __mbtowc_state_defined
#define __mbtowc_state_defined 1
PRIVATE mbstate_t mbtowc_state = MBSTATE_INIT;
#endif /* !__mbtowc_state_defined */

DECL size_t LIBCCALL Xmb(towc)(T *__restrict pwc, char const *__restrict s, size_t n) {
	return Xmb(rtowc)(pwc,s,n,&mbtowc_state);
}

DECL size_t LIBCCALL Xmb(snrtowcs)
(T *__restrict dst, char const **__restrict src,
 size_t nmc, size_t len, struct __mbstate *__restrict ps) {
	size_t result;
	result = UTF8TOX((char const *)src,(size_t)&nmc,dst,len,ps,
	                  UNICODE_F_ALWAYSZEROTERM|UNICODE_F_STOPONNUL|
	                  UNICODE_F_UPDATESRC);
	if (result != UNICODE_ERROR) --result;
	return result;
}

DECL size_t LIBCCALL Xmb(srtowcs)
(T *__restrict dst, char const **__restrict src,
 size_t len, struct __mbstate *__restrict ps) {
	return Xmb(snrtowcs)(dst,src,(size_t)-1,len,ps);
}
DECL size_t LIBCCALL Xmb(stowcs)
(T *__restrict pwcs, char const *__restrict s, size_t n) {
	return Xmb(srtowcs)(pwcs,(char const **)&s,n,&mbtowc_state);
}

#endif /* WANT_MBTOWC */


#ifdef WANT_WCTOMB
#undef WANT_WCTOMB
DECL size_t LIBCCALL Xwc(rtomb)(char *__restrict s, T wc, struct __mbstate *__restrict ps) {
	if (!s) { mbstate_reset(ps); return UNICODE_IS_STATEDEPENDENT; }
	return UTFXTO8(&wc,1,s,UNICODE_MB_MAX,ps,
	               UNICODE_F_NOZEROTERM|UNICODE_F_STOPONNUL|
	               UNICODE_F_DOSINGLE);
}

#ifndef __wctomb_state_defined
#define __wctomb_state_defined 1
PRIVATE mbstate_t wctomb_state = MBSTATE_INIT;
#endif /* !__wctomb_state_defined */

DECL size_t LIBCCALL Xwc(tomb)(char *s, T wc) {
	return Xwc(rtomb)(s,wc,&wctomb_state);
}

DECL size_t LIBCCALL Xwc(snrtombs)
(char *__restrict dst, T const **__restrict src,
 size_t nwc, size_t len, struct __mbstate *__restrict ps) {
	size_t result;
	result = UTFXTO8((T const *)src,(size_t)&nwc,dst,len,ps,
	                  UNICODE_F_ALWAYSZEROTERM|UNICODE_F_STOPONNUL|
	                  UNICODE_F_UPDATESRC);
	if (result != UNICODE_ERROR) --result;
	return result;
}
DECL size_t LIBCCALL Xwc(srtombs)
(char *__restrict dst, T const **__restrict src,
 size_t len, struct __mbstate *__restrict ps) {
	return Xwc(snrtombs)(dst,src,(size_t)-1,len,ps);
}
DECL size_t LIBCCALL Xwc(stombs)
(char *__restrict dst, T const *__restrict pwcs, size_t n) {
	return Xwc(srtombs)(dst,(T const **)&pwcs,n,&wctomb_state);
}

#endif /* WANT_WCTOMB */

#ifdef WANT_WCWIDTH
#undef WANT_WCWIDTH
DECL size_t LIBCCALL Xwc(swidth)(T const *s, size_t n) {
	mbstate_t state = MBSTATE_INIT;
	return UTFXTO8(s,n,NULL,0,&state,UNICODE_F_NOZEROTERM|UNICODE_F_STOPONNUL);
}
DECL size_t LIBCCALL Xwc(width)(T c) {
	return Xwc(swidth)(&c,1);
}
#endif /* WANT_WCWIDTH */

#ifdef WANT_MBSRTOWCS_S
#undef WANT_MBSRTOWCS_S
DECL errno_t LIBCCALL Xmb(srtowcs_s)
(size_t *result, T *__restrict buf, size_t buflen,
 char const **__restrict psrc, size_t srcsize,
 mbstate_t *__restrict ps) {
	size_t res = Xmb(snrtowcs)(buf,psrc,srcsize,buflen,ps);
	if (result) *result = res;
	return res != (size_t)-1 ? EOK : EILSEQ;
}
#endif /* WANT_MBSRTOWCS_S */

#ifdef WANT_WCSRTOMBS_S
#undef WANT_WCSRTOMBS_S
DECL errno_t LIBCCALL Xwc(srtombs_s)
(size_t *result, char *__restrict buf, size_t buflen,
 T const **__restrict psrc, size_t srcsize, mbstate_t *__restrict ps) {
	return Xwc(snrtombs)(buf,psrc,srcsize,buflen,ps);
}
#endif /* WANT_WCSRTOMBS_S */

#ifdef WANT_WCRTOMB_S
#undef WANT_WCRTOMB_S
DECL errno_t LIBCCALL Xwc(rtomb_s)
(size_t *result, char *__restrict buf,
 size_t buflen, T wc, mbstate_t *__restrict ps) {
	size_t res;
	if (!buf) {
		mbstate_reset(ps);
		res = UNICODE_IS_STATEDEPENDENT;
	} else {
		res = UTFXTO8(&wc,1,buf,buflen,ps,
		              UNICODE_F_NOZEROTERM|UNICODE_F_STOPONNUL|
		              UNICODE_F_DOSINGLE);
	}
	if (result) *result = res;
	return res != (size_t)-1 ? EOK : EILSEQ;
}
#endif /* WANT_WCRTOMB_S */


/* String -> integer parsing. */
#ifdef WANT_STRTOU32
#undef WANT_STRTOU32
DECL u32 LIBCCALL
Xstr(tou32)(T const *__restrict nptr, T **endptr, int base) {
	u32 result,temp;
	if (!base) {
		if (*nptr == '0') {
			++nptr;
			if (*nptr == 'x' || *nptr == 'X') ++nptr,base = 16;
			else if (*nptr == 'b' || *nptr == 'B') ++nptr,base = 2;
			else base = 8;
		} else base = 10;
	}
	result = 0;
	for (;;) {
		T ch = *nptr;
		if (ch >= '0' && ch <= '9') temp = (u32)(ch-'0');
		else if (ch >= 'a' && ch <= 'z') temp = (u32)(10+(ch-'a'));
		else if (ch >= 'A' && ch <= 'Z') temp = (u32)(10+(ch-'A'));
		else break;
		if (temp >= (u32)base) break;
		++nptr;
		result *= base;
		result += temp;
	}
	if (endptr) *endptr = (T *)nptr;
	return result;
}
#endif /* WANT_STRTOU32 */

#ifdef WANT_STRTOU64
#undef WANT_STRTOU64
DECL u64 LIBCCALL
Xstr(tou64)(T const *__restrict nptr, T **endptr, int base) {
	u64 result,temp;
	if (!base) {
		if (*nptr == '0') {
			++nptr;
			if (*nptr == 'x' || *nptr == 'X') ++nptr,base = 16;
			else if (*nptr == 'b' || *nptr == 'B') ++nptr,base = 2;
			else base = 8;
		} else base = 10;
	}
	result = 0;
	for (;;) {
		T ch = *nptr;
		if (ch >= '0' && ch <= '9') temp = (u64)(ch-'0');
		else if (ch >= 'a' && ch <= 'z') temp = (u64)(10+(ch-'a'));
		else if (ch >= 'A' && ch <= 'Z') temp = (u64)(10+(ch-'A'));
		else break;
		if (temp >= (u64)base) break;
		++nptr;
		result *= base;
		result += temp;
	}
	if (endptr) *endptr = (T *)nptr;
	return result;
}
#endif /* WANT_STRTOU64 */

#ifdef WANT_STRTO32
#undef WANT_STRTO32
DECL s32 LIBCCALL Xstr(to32)(T const *__restrict nptr, T **endptr, int base) {
	bool is_neg = false; s32 result;
	while (*nptr == '-') { is_neg ^= 1; ++nptr; }
	result = (s32)Xstr(tou32)(nptr,endptr,base);
	if (is_neg) result = -result;
	return result;
}
#endif /* WANT_STRTO64 */

#ifdef WANT_STRTO64
#undef WANT_STRTO64
DECL s64 LIBCCALL Xstr(to64)(T const *__restrict nptr, T **endptr, int base) {
	bool is_neg = false; s64 result;
	while (*nptr == '-') { is_neg ^= 1; ++nptr; }
	result = (s64)Xstr(tou64)(nptr,endptr,base);
	if (is_neg) result = -result;
	return result;
}
#endif /* WANT_STRTO64 */

#ifdef WANT_STRTOU32_L
#undef WANT_STRTOU32_L
#ifdef CONFIG_LIBCCALL_HAS_CALLER_ARGUMENT_CLEANUP
DEFINE_ALIAS(Xstr(tou32_l),Xstr(tou32));
#else
DECL u32 LIBCCALL
Xstr(tou32_l)(T const *__restrict nptr, T **endptr, int base, locale_t UNUSED(locale)) {
	return Xstr(tou32)(nptr,endptr,base);
}
#endif
#endif /* WANT_STRTOU32_L */

#ifdef WANT_STRTOU64_L
#undef WANT_STRTOU64_L
#ifdef CONFIG_LIBCCALL_HAS_CALLER_ARGUMENT_CLEANUP
DEFINE_ALIAS(Xstr(tou64_l),Xstr(tou64));
#else
DECL u64 LIBCCALL
Xstr(tou64_l)(T const *__restrict nptr, T **endptr, int base, locale_t UNUSED(locale)) {
	return Xstr(tou64)(nptr,endptr,base);
}
#endif
#endif /* WANT_STRTOU64_L */

#ifdef WANT_STRTO32_L
#undef WANT_STRTO32_L
#ifdef CONFIG_LIBCCALL_HAS_CALLER_ARGUMENT_CLEANUP
DEFINE_ALIAS(Xstr(to32_l),Xstr(to32));
#else
DECL s32 LIBCCALL
Xstr(to32_l)(T const *__restrict nptr, T **endptr, int base, locale_t UNUSED(locale)) {
	return Xstr(to32)(nptr,endptr,base);
}
#endif
#endif /* WANT_STRTO32_L */

#ifdef WANT_STRTO64_L
#undef WANT_STRTO64_L
#ifdef CONFIG_LIBCCALL_HAS_CALLER_ARGUMENT_CLEANUP
DEFINE_ALIAS(Xstr(to64_l),Xstr(to64));
#else
DECL s32 LIBCCALL
Xstr(to64_l)(T const *__restrict nptr, T **endptr, int base, locale_t UNUSED(locale)) {
	return Xstr(to64)(nptr,endptr,base);
}
#endif
#endif /* WANT_STRTO64_L */

#ifdef WANT_ATO32
#undef WANT_ATO32
DECL s32 LIBCCALL
Xa(to32)(T const *__restrict nptr) {
	return Xstr(to32)(nptr,NULL,10);
}
#endif /* WANT_ATO32 */

#ifdef WANT_ATO64
#undef WANT_ATO64
DECL s64 LIBCCALL
Xa(to64)(T const *__restrict nptr) {
	return Xstr(to64)(nptr,NULL,10);
}
#endif /* WANT_ATO32 */

#ifdef WANT_ATO32_L
#undef WANT_ATO32_L
#ifdef CONFIG_LIBCCALL_HAS_CALLER_ARGUMENT_CLEANUP
DEFINE_ALIAS(Xa(to32_l),Xa(to32));
#else
DECL s32 LIBCCALL
Xa(to32_l)(T const *__restrict nptr, locale_t UNUSED(locale)) {
	return Xa(to32)(nptr);
}
#endif
#endif /* WANT_ATO32 */

#ifdef WANT_ATO64_L
#undef WANT_ATO64_L
#ifdef CONFIG_LIBCCALL_HAS_CALLER_ARGUMENT_CLEANUP
DEFINE_ALIAS(Xa(to64_l),Xa(to64));
#else
DECL s64 LIBCCALL
Xa(to64_l)(T const *__restrict nptr, locale_t UNUSED(locale)) {
	return Xa(to64)(nptr);
}
#endif
#endif /* WANT_ATO32 */


#ifdef WANT_STRTOLD
#undef WANT_STRTOLD
DECL long double LIBCCALL
Xstr(told)(T const *__restrict nptr, T **__restrict endptr) {
	long double result = 0.0L; T ch;
	long double float_extension_mult = 0.0L;
	int numsys,more;
	if (*nptr == '0') {
		if (!*++nptr) return 0.0L;
		if (*nptr == 'x' || *nptr == 'X') {
			if unlikely(!*++nptr) goto err;
			numsys = 16;
		} else if (*nptr == 'b' || *nptr == 'B') {
			if unlikely(!*++nptr) goto err;
			numsys = 2;
		} else if (*nptr == '.') {
			numsys = 10;
		} else {
			numsys = 8;
		}
	} else {
		numsys = 10;
	}
	float_extension_mult = 0;
	for (;;) {
next:
		switch ((ch = *nptr++)) {
		case '.': float_extension_mult = (long double)numsys; goto next;
		case 'p': case 'P': goto flt_ext;
		case 'e': case 'E': if (numsys < (10+'e'-'a')) goto flt_ext; /* fallthrough */
		default:
			if (ch >= '0' && ch <= '9') { more = ch-'0'; break; }
			if (ch >= 'a' && ch <= 'f') { more = 10+ch-'a'; break; }
			if (ch >= 'A' && ch <= 'F') { more = 10+ch-'A'; break; }
			--nptr;
			goto done;
		}
		if (unlikely(more >= numsys)) goto err;
		if (float_extension_mult != 0.0L) {
			result += ((long double)more)/float_extension_mult;
			float_extension_mult *= numsys;
		} else {
			result = result*numsys+more;
		}
	}
done:
	if (endptr) *endptr = (T *)nptr;
	return result;
flt_ext:
#define float_extension_pos numsys
#define float_extension_off more
	/* Read the Float extension: E[+/-][int] */
	float_extension_pos = 1;
	float_extension_off = 0;
	if (!*nptr) goto err;
	ch = *nptr++;
	if (ch == '-' || ch == '+') {
		float_extension_pos = (ch == '+');
		if (!*nptr) goto err;
		ch = *nptr++;
	}
	while (ch >= '0' && ch <= '9') {
		float_extension_off = float_extension_off*10+(ch-'0');
		if ((ch = *nptr) == NUL) break;
		++nptr;
	}
	float_extension_mult = 1;
	while (float_extension_off != 0) {
		float_extension_mult *= 10;
		--float_extension_off;
	}
	if (float_extension_pos) {
		result *= float_extension_mult;
	} else {
		result /= float_extension_mult;
	}
	goto done;
#undef float_extension_pos
#undef float_extension_off
err:
#if 1 /* This is what STDC wants... */
	result = 0.0L;
#else /* This is what I'd like to do... */
	SET_ERRNO(EINVAL);
	result = -1.0L;
#endif
	goto done;
}
#endif /* WANT_STRTOLD */

#ifdef WANT_STRTOF
#undef WANT_STRTOF
DECL float LIBCCALL
Xstr(tof)(T const *__restrict nptr, T **__restrict endptr) {
	return (float)Xstr(told)(nptr,endptr);
}
#endif /* WANT_STRTOF */

#ifdef WANT_STRTOD
#undef WANT_STRTOD
DECL double LIBCCALL
Xstr(tod)(T const *__restrict nptr, T **__restrict endptr) {
	return (double)Xstr(told)(nptr,endptr);
}
#endif /* WANT_STRTOD */

#ifdef WANT_STRTOLD_L
#undef WANT_STRTOLD_L
#ifdef CONFIG_LIBCCALL_HAS_CALLER_ARGUMENT_CLEANUP
DEFINE_ALIAS(Xstr(told_l),Xstr(told));
#else
DECL long double LIBCCALL
Xa(told_l)(T const *__restrict nptr, T **__restrict endptr, locale_t UNUSED(locale)) {
	return Xstr(told)(nptr,endptr);
}
#endif
#endif /* WANT_STRTOLD_L */

#ifdef WANT_STRTOD_L
#undef WANT_STRTOD_L
#ifdef CONFIG_LIBCCALL_HAS_CALLER_ARGUMENT_CLEANUP
DEFINE_ALIAS(Xstr(tod_l),Xstr(tod));
#else
DECL double LIBCCALL
Xa(tod_l)(T const *__restrict nptr, T **__restrict endptr, locale_t UNUSED(locale)) {
	return Xstr(tod)(nptr,endptr);
}
#endif
#endif /* WANT_STRTOD_L */

#ifdef WANT_STRTOF_L
#undef WANT_STRTOF_L
#ifdef CONFIG_LIBCCALL_HAS_CALLER_ARGUMENT_CLEANUP
DEFINE_ALIAS(Xstr(tof_l),Xstr(tof));
#else
DECL float LIBCCALL
Xa(tof_l)(T const *__restrict nptr, T **__restrict endptr, locale_t UNUSED(locale)) {
	return Xstr(tof)(nptr,endptr);
}
#endif
#endif /* WANT_STRTOF_L */

#ifdef WANT_ATOF
#undef WANT_ATOF
DECL double LIBCCALL
Xa(tof)(T const *__restrict nptr) {
	return Xstr(tod)(nptr,NULL);
}
#endif /* WANT_ATO32 */

#ifdef WANT_ATOF_L
#undef WANT_ATOF_L
#ifdef CONFIG_LIBCCALL_HAS_CALLER_ARGUMENT_CLEANUP
DEFINE_ALIAS(Xa(tof_l),Xa(tof));
#else
DECL double LIBCCALL
Xa(tof_l)(T const *__restrict nptr, locale_t UNUSED(locale)) {
	return Xa(tof)(nptr);
}
#endif
#endif /* WANT_ATO32_L */


#ifdef WANT_U32TOA_S
#undef WANT_U32TOA_S
DECL errno_t LIBCCALL
Xxa_s(u32to)(u32 val, T *dst, size_t bufsize, int radix) {
	NOT_IMPLEMENTED();
	return __DOS_ENOSYS;
}
#endif /* WANT_U64TOA_S */

#ifdef WANT_U64TOA_S
#undef WANT_U64TOA_S
DECL errno_t LIBCCALL
Xxa_s(u64to)(u64 val, T *dst, size_t bufsize, int radix) {
	NOT_IMPLEMENTED();
	return __DOS_ENOSYS;
}
#endif /* WANT_U64TOA_S */

#ifdef WANT_S32TOA_S
#undef WANT_S32TOA_S
DECL errno_t LIBCCALL
Xxa_s(s32to)(s32 val, T *dst, size_t bufsize, int radix) {
	NOT_IMPLEMENTED();
	return __DOS_ENOSYS;
}
#endif /* WANT_S32TOA_S */

#ifdef WANT_S64TOA_S
#undef WANT_S64TOA_S
DECL errno_t LIBCCALL
Xxa_s(s64to)(s64 val, T *dst, size_t bufsize, int radix) {
	NOT_IMPLEMENTED();
	return __DOS_ENOSYS;
}
#endif /* WANT_S64TOA_S */

#ifdef WANT_U32TOA
#undef WANT_U32TOA
DECL T *LIBCCALL Xxa(u32to)(u32 val, T *dst, int radix) {
	return Xxa_s(u32to)(val,dst,(size_t)-1,radix) ? NULL : dst;
}
#endif /* WANT_U64TOA */

#ifdef WANT_U64TOA
#undef WANT_U64TOA
DECL T *LIBCCALL Xxa(u64to)(u64 val, T *dst, int radix) {
	return Xxa_s(u64to)(val,dst,(size_t)-1,radix) ? NULL : dst;
}
#endif /* WANT_U64TOA */

#ifdef WANT_S32TOA
#undef WANT_S32TOA
DECL T *LIBCCALL Xxa(s32to)(s32 val, T *dst, int radix) {
	return Xxa_s(s32to)(val,dst,(size_t)-1,radix) ? NULL : dst;
}
#endif /* WANT_S32TOA */

#ifdef WANT_S64TOA
#undef WANT_S64TOA
DECL T *LIBCCALL Xxa(s64to)(s64 val, T *dst, int radix) {
	return Xxa_s(s64to)(val,dst,(size_t)-1,radix) ? NULL : dst;
}
#endif /* WANT_S64TOA */


#ifdef WANT_SPLITPATH_S
#undef WANT_SPLITPATH_S
DECL errno_t LIBCCALL X(splitpath_s)
(T const *__restrict abspath, T *drive, size_t drivelen,
 T *dir, size_t dirlen, T *file, size_t filelen,
 T *ext, size_t extlen) {
	if (!drive) drivelen = 0;
	if (!dir) dirlen = 0;
	if (!file) filelen = 0;
	if (!ext) extlen = 0;

	(void)drivelen;
	(void)dirlen;
	(void)filelen;
	(void)extlen;
	/* TODO */
	
	NOT_IMPLEMENTED();
	return EINVAL;
}
#endif

#ifdef WANT_SPLITPATH
#undef WANT_SPLITPATH
DECL void LIBCCALL X(splitpath)
(T const *__restrict abspath, T *drive, T *dir, T *file, T *ext) {
	X(splitpath_s)(abspath,
	               drive,__DOS_MAX_DRIVE,
	               dir,__DOS_MAX_DIR,
	               file,__DOS_MAX_FNAME,
	               ext,__DOS_MAX_EXT);
}
#endif


#undef DEFINE_ALIAS
#ifdef DOS_DECL
#undef DOS_DECL
#endif
#undef DECL
#undef UTFXTO8
#undef UTF8TOX
#undef STR_MEMPCPY
#undef STR_MEMCPY
#undef STR_MEMSET
#undef NUL
#undef T
#undef Tneedle
#undef Ts
#undef Tu
#undef Tn
#undef Xstr
#undef Xstp
#ifdef X
#undef X
#endif
#ifdef Xmb
#undef Xmb
#endif
#ifdef Xa
#undef Xa
#endif
#ifdef Xxa
#undef Xxa
#endif
#ifdef Xxa_s
#undef Xxa_s
#endif
#ifdef Xwc
#undef Xwc
#endif
#undef S
#undef TOLOWER
#undef TOUPPER
#undef NO_CASELOCALE
#undef TOLOWER_L
#undef TOUPPER_L
