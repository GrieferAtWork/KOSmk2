/* Copyright (c) 2017 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

/*
 * #define T          ... <character type> (e.g.: 'char', 'char32_t')
 * #define Tneedle    ... <needle type> (e.g.: 'int', 'char32_t')
 * #define Ts         ... <signed type> (e.g.: 'signed char', 's32')
 * #define Tu         ... <unsigned type> (e.g.: 'unsigned char', 'u32')
 * #define Tn         ... <needle type> (e.g.: 'int', 'char32_t')
 * #define Xstr(x)    ... <Symbol name generator> (e.g.: 'libc_str##x', 'libc_32wcs##x')
 * #define Xstp(x)    ... <Symbol name generator> (e.g.: 'libc_stp##x', 'libc_32wcp##x')
 * #define Xmb(x)     ... <Symbol name generator> (e.g.: 'libc_32mb##x') [OPTIONAL]
 * #define Xwc(x)     ... <Symbol name generator> (e.g.: 'libc_32wc##x') [OPTIONAL]
 * #define S          ... <Bit-width in bytes> (e.g.: '__SIZEOF_CHAR__', '__SIZEOF_WCHAR_T__')
 * #define NUL        ... <\0-character; defaults to ZERO(0)>
 * #define TOLOWER(x) ... <tolower()-function>
 * #define TOUPPER(x) ... <toupper()-function>
 * #define IS_WIDE	  ... <defined for the WIDE-API>
 */ 
#ifndef NUL
#define NUL 0
#endif

#if S == 1
#define STR_MEMCPY(dst,src,n) ((T *)libc_memcpy(dst,src,n))
#elif S == 2
#define STR_MEMCPY(dst,src,n) ((T *)libc_memcpyw(dst,src,n))
#elif S == 4
#define STR_MEMCPY(dst,src,n) ((T *)libc_memcpyl(dst,src,n))
#elif S == 8 && defined(CONFIG_64BIT_STRING)
#define STR_MEMCPY(dst,src,n) ((T *)libc_memcpyq(dst,src,n))
#else
#define STR_MEMCPY(dst,src,n) ((T *)libc_memcpyq(dst,src,(n)*S))
#endif


DECL int LIBCCALL Xstr(cmp)(T const *s1, T const *s2) {
	T a,b; int result;
	do {
		a = *s1++,b = *s2++,
		result = (int)a-(int)b;
	} while (result == 0 && a);
	return result;
}

DECL T *LIBCCALL Xstr(end)(T const *__restrict str) {
	for (; *str; ++str);
	return (T *)str;
}

DECL T *LIBCCALL Xstr(nend)
(T const *__restrict str, size_t maxlen) {
	T *end = (T *)str+maxlen;
	for (; str != end && *str; ++str);
	return (T *)str;
}

DECL size_t LIBCCALL Xstr(len)
(T const *__restrict str) {
	return (size_t)(Xstr(end)(str)-str);
}

DECL size_t LIBCCALL Xstr(nlen)
(T const *__restrict str, size_t maxlen) {
	return (size_t)(Xstr(nend)(str,maxlen)-str);
}

DECL T *LIBCCALL Xstr(chrnul)
(T const *__restrict haystack, Tneedle needle) {
	T *iter = (T *)haystack;
	for (; *iter && *iter != (T)needle; ++iter);
	return iter;
}

DECL T *LIBCCALL Xstr(chr)
(T const *__restrict haystack, Tneedle needle) {
	T *iter = (T *)haystack;
	for (; *iter; ++iter) if (*iter == (T)needle) return iter;
	return NULL;
}

DECL T *LIBCCALL Xstr(rchr)
(T const *__restrict haystack, Tneedle needle) {
	T *result = NULL,*iter = (T *)haystack;
	for (; *iter; ++iter) if (*iter == (T)needle) result = iter;
	return result;
}

#ifndef IS_WIDE
DECL T *LIBCCALL Xstr(rchrnul)
(T const *__restrict haystack, Tneedle needle) {
	T *result = NULL,*iter = (T *)haystack;
	for (; *iter; ++iter) if (*iter == (T)needle) result = iter;
	return result ? result : (T *)haystack-1;
}

DECL T *LIBCCALL Xstr(nchr)
(T const *__restrict haystack, Tneedle needle, size_t max_chars) {
	T *iter = (T *)haystack,*end = iter+max_chars;
	for (; iter != end && *iter; ++iter) if (*iter == (T)needle) return iter;
	return NULL;
}

DECL T *LIBCCALL Xstr(nrchr)
(T const *__restrict haystack, Tneedle needle, size_t max_chars) {
	T *iter = (T *)haystack,*end = iter+max_chars,*result = NULL;
	for (; iter != end && *iter; ++iter) if (*iter == (T)needle) result = iter;
	return result;
}

DECL T *LIBCCALL Xstr(nchrnul)
(T const *__restrict haystack, Tneedle needle, size_t max_chars) {
	T *iter = (T *)haystack,*end = iter+max_chars;
	for (; iter != end && *iter && *iter != (T)needle; ++iter);
	return iter;
}

DECL T *LIBCCALL Xstr(nrchrnul)
(T const *__restrict haystack, Tneedle needle, size_t max_chars) {
	T *iter = (T *)haystack,*end = iter+max_chars,*result = NULL;
	for (; iter != end && *iter; ++iter) if (*iter == (T)needle) result = iter;
	return result ? result : (T *)haystack-1;
}

DECL size_t LIBCCALL Xstr(off)
(T const *__restrict haystack, Tneedle needle) {
	return Xstr(chrnul)(haystack,needle)-haystack;
}

DECL size_t LIBCCALL Xstr(roff)
(T const *__restrict haystack, Tneedle needle) {
	return Xstr(rchrnul)(haystack,needle)-haystack;
}

DECL size_t LIBCCALL Xstr(noff)
(T const *__restrict haystack, Tneedle needle, size_t max_chars) {
	return Xstr(nchrnul)(haystack,needle,max_chars)-haystack;
}

DECL size_t LIBCCALL Xstr(nroff)
(T const *__restrict haystack, Tneedle needle, size_t max_chars) {
	return Xstr(nrchrnul)(haystack,needle,max_chars)-haystack;
}
#endif /* !IS_WIDE */

DECL T *LIBCCALL Xstp(cpy)
(T *__restrict dst, T const *__restrict src) {
	size_t len = Xstr(len)(src);
	STR_MEMCPY(dst,src,len+1);
	return dst+len;
}

DECL T *LIBCCALL Xstp(ncpy)
(T *__restrict dst, T const *__restrict src, size_t n) {
	size_t len = Xstr(nlen)(src,n);
	STR_MEMCPY(dst,src,len+!src[len]);
	return dst+len;
}

DECL int LIBCCALL Xstr(ncmp)(T const *s1, T const *s2, size_t n) {
 T a,b,*end = (T *)s1+n; int result;
 if (n) {
	do {
		a = *s1++,b = *s2++,
		result = (int)a-(int)b;
	} while (result == 0 && a && s1 != end);
 }
 return result;
}

DECL int LIBCCALL Xstr(casecmp)(T const *s1, T const *s2) {
	T a,b; int result;
	do {
		a = TOLOWER(*s1++),
		b = TOLOWER(*s2++),
		result = (int)a-(int)b;
	} while (result == 0 && a);
	return result;
}

DECL int LIBCCALL Xstr(ncasecmp)(T const *s1, T const *s2, size_t n) {
 T a,b,*end = (T *)s1+n; int result;
 if (n) {
	do {
		a = TOLOWER(*s1++),
		b = TOLOWER(*s2++),
		result = (int)a-(int)b;
	} while (result == 0 && a && s1 != end);
 }
 return result;
}

DECL T *LIBCCALL Xstr(str)
(T const *haystack, T const *needle) {
	T *hay_iter = (assert(haystack),(T *)haystack),*hay2;
	T ch,needle_start = (assert(needle),*needle++);
	T const *ned_iter;
	while ((ch = *hay_iter++) != NUL) {
		if (ch == needle_start) {
			hay2 = hay_iter,ned_iter = needle;
			while ((ch = *ned_iter++) != NUL) {
				if (*hay2++ != ch) goto miss;
			}
			return hay_iter-1;
		}
miss:;
	}
	return NULL;
}


#ifndef IS_WIDE
DECL T *LIBCCALL Xstr(casestr)(T const *haystack, T const *needle) {
	T *hay_iter = (assert(haystack),(T *)haystack),*hay2;
	T ch,needle_start = (assert(needle),*needle++);
	T const *ned_iter;
	while ((ch = *hay_iter++) != NUL) {
		if (ch == needle_start) {
			hay2 = hay_iter,ned_iter = needle;
			while ((ch = *ned_iter++) != NUL) {
				if (TOLOWER(*hay2++) != TOLOWER(ch))
					goto miss;
			}
			return hay_iter-1;
		}
miss:;
	}
	return NULL;
}
#endif /* !IS_WIDE */

#ifndef __KERNEL__
DECL T *LIBCCALL Xstr(cpy)
(T *__restrict dst, T const *__restrict src) {
	return STR_MEMCPY(dst,src,Xstr(len)(src)+1);
}

DECL T *LIBCCALL Xstr(ncpy)
(T *__restrict dst, T const *__restrict src, size_t n) {
	return STR_MEMCPY(dst,src,Xstr(nlen)(src,n)+1);
}

DECL T *LIBCCALL Xstr(cat)(T *__restrict dst, T const *__restrict src) {
	STR_MEMCPY(Xstr(end)(dst),src,Xstr(len)(src)+1);
	return dst;
}

DECL T *LIBCCALL Xstr(ncat)(T *__restrict dst, T const *__restrict src, size_t n) {
	size_t maxlen = Xstr(nlen)(src,n);
	T *target = Xstr(end)(dst);
	STR_MEMCPY(target,src,maxlen);
	if (maxlen < n) target[maxlen] = NUL;
	return dst;
}
DECL size_t LIBCCALL Xstr(cspn)(T const *s, T const *reject) {
	T const *iter = s;
	while (*iter && !Xstr(chr)(reject,*iter)) ++iter;
	return (size_t)(iter-s);
}
DECL size_t LIBCCALL Xstr(spn)(T const *s, T const *accept) {
	T const *iter = s;
	while (Xstr(chr)(accept,*iter)) ++iter;
	return (size_t)(iter-s);
}
DECL T *LIBCCALL Xstr(pbrk)(T const *s, T const *accept) {
	T *hay_iter = (T *)s,haych,ch;
	T const *ned_iter;
	while ((haych = *hay_iter++) != NUL) {
		ned_iter = accept;
		while ((ch = *ned_iter++) != NUL) {
			if (haych == ch) return hay_iter-1;
		}
	}
	return NULL;
}

#ifdef IS_WIDE
DECL T *LIBCCALL Xstr(tok)
#else
DECL T *LIBCCALL Xstr(tok_r)
#endif
(T *__restrict s, T const *__restrict delim, T **__restrict save_ptr) {
	T *end;
	if (!s) s = *save_ptr;
	if (!*s) { *save_ptr = s; return NULL; }
	s += Xstr(spn)(s,delim);
	if (!*s) { *save_ptr = s; return NULL; }
	end = s+Xstr(cspn)(s,delim);
	if (!*end) { *save_ptr = end; return s; }
	*end = NUL;
	*save_ptr = end+1;
	return s;
}
#ifndef IS_WIDE
DECL T *LIBCCALL Xstr(tok)(T *__restrict s, T const *__restrict delim) {
	PRIVATE T *safe = NULL;
	return Xstr(tok_r)(s,delim,&safe);
}
#endif /* !IS_WIDE */

#endif /* !__KERNEL__ */


/* Wide-string UTF conversion functions. */
#if S == 4
#define UTFXTO8  libc_utf32to8
#define UTF8TOX  libc_utf8to32
#elif S == 2
#define UTFXTO8  libc_utf16to8
#define UTF8TOX  libc_utf8to16
#endif



#ifdef WANT_MBLEN
#undef WANT_MBLEN
DECL size_t LIBCCALL Xmb(rlen)
(char const *__restrict s, size_t n, struct __mbstate *__restrict ps) {
	if (!s) { mbstate_reset(ps); return 0; }
	return (ssize_t)UTF8TOX(s,n,NULL,0,ps,
	                        UNICODE_F_STOPONNUL|
	                        UNICODE_F_NOZEROTERM);
}

#ifndef __mblen_state_defined
#define __mblen_state_defined 1
PRIVATE mbstate_t mblen_state = MBSTATE_INIT;
#endif /* !__mblen_state_defined */

DECL size_t LIBCCALL Xmb(len)(char const *s, size_t n) {
	return Xmb(rlen)(s,n,&mblen_state);
}
#endif /* WANT_MBLEN */



#ifdef WANT_MBTOWC
#undef WANT_MBTOWC
DECL size_t LIBCCALL Xmb(rtowc)
(T *__restrict pwc, char const *__restrict s, size_t n, struct __mbstate *__restrict ps) {
	size_t result; char const *start = s;
	if (!s) { mbstate_reset(ps); return 0; }
	result = UTF8TOX((char const *)&s,(size_t)&n,pwc,pwc ? 1 : 0,ps,
	                  UNICODE_F_NOZEROTERM|UNICODE_F_STOPONNUL|
	                  UNICODE_F_UTF16HALF|UNICODE_F_DOSINGLE);
	if (result == UNICODE_ERROR) return -1;
	return (ssize_t)(s-start);
}

#ifndef __mbtowc_state_defined
#define __mbtowc_state_defined 1
PRIVATE mbstate_t mbtowc_state = MBSTATE_INIT;
#endif /* !__mbtowc_state_defined */

DECL size_t LIBCCALL Xmb(towc)(T *__restrict pwc, char const *__restrict s, size_t n) {
	return Xmb(rtowc)(pwc,s,n,&mbtowc_state);
}

DECL size_t LIBCCALL Xmb(snrtowcs)
(char32_t *__restrict dst, char const **__restrict src,
 size_t nmc, size_t len, struct __mbstate *__restrict ps) {
	size_t result;
	result = UTF8TOX((char const *)src,(size_t)&nmc,dst,len,ps,
	                  UNICODE_F_ALWAYSZEROTERM|UNICODE_F_STOPONNUL|
	                  UNICODE_F_UPDATESRC);
	if (result != UNICODE_ERROR) --result;
	return result;
}

DECL size_t LIBCCALL Xmb(srtowcs)
(T *__restrict dst, char const **__restrict src,
 size_t len, struct __mbstate *__restrict ps) {
	return Xmb(snrtowcs)(dst,src,(size_t)-1,len,ps);
}
DECL size_t LIBCCALL Xmb(stowcs)
(T *__restrict pwcs, char const *__restrict s, size_t n) {
	return Xmb(srtowcs)(pwcs,(char const **)&s,n,&mbtowc_state);
}

#endif /* WANT_MBTOWC */


#ifdef WANT_WCTOMB
#undef WANT_WCTOMB
DECL size_t LIBCCALL Xwc(rtomb)(char *__restrict s, T wc, struct __mbstate *__restrict ps) {
	if (!s) { mbstate_reset(ps); return UNICODE_IS_STATEDEPENDENT; }
	return UTFXTO8(&wc,1,s,UNICODE_MB_MAX,ps,
	               UNICODE_F_NOZEROTERM|UNICODE_F_STOPONNUL|
	               UNICODE_F_DOSINGLE);
}

#ifndef __wctomb_state_defined
#define __wctomb_state_defined 1
PRIVATE mbstate_t wctomb_state = MBSTATE_INIT;
#endif /* !__wctomb_state_defined */

DECL size_t LIBCCALL Xwc(tomb)(char *s, T wc) {
	return Xwc(rtomb)(s,wc,&wctomb_state);
}

DECL size_t LIBCCALL Xwc(snrtombs)
(char *__restrict dst, T const **__restrict src,
 size_t nwc, size_t len, struct __mbstate *__restrict ps) {
	size_t result;
	result = UTFXTO8((T const *)src,(size_t)&nwc,dst,len,ps,
	                  UNICODE_F_ALWAYSZEROTERM|UNICODE_F_STOPONNUL|
	                  UNICODE_F_UPDATESRC);
	if (result != UNICODE_ERROR) --result;
	return result;
}
DECL size_t LIBCCALL Xwc(srtombs)
(char *__restrict dst, T const **__restrict src,
 size_t len, struct __mbstate *__restrict ps) {
	return Xwc(snrtombs)(dst,src,(size_t)-1,len,ps);
}
DECL size_t LIBCCALL Xwc(stombs)
(char *__restrict dst, T const *__restrict pwcs, size_t n) {
	return Xwc(srtombs)(dst,(T const **)&pwcs,n,&wctomb_state);
}

#endif /* WANT_WCTOMB */

#ifdef WANT_WCWIDTH
#undef WANT_WCWIDTH
DECL size_t LIBCCALL Xwc(swidth)(T const *s, size_t n) {
	mbstate_t state = MBSTATE_INIT;
	return UTFXTO8(s,n,NULL,0,&state,UNICODE_F_NOZEROTERM|UNICODE_F_STOPONNUL);
}
INTERN size_t LIBCCALL Xwc(width)(T c) {
	return Xwc(swidth)(&c,1);
}
#endif /* WANT_WCWIDTH */


#undef UTFXTO8
#undef UTF8TOX
#undef STR_MEMCPY
#undef NUL
#undef T
#undef Tneedle
#undef Ts
#undef Tu
#undef Tn
#undef Xstr
#undef Xstp
#ifdef Xmb
#undef Xmb
#endif
#ifdef Xwc
#undef Xwc
#endif
#undef S
#undef TOLOWER
#undef TOUPPER
#ifdef IS_WIDE
#undef IS_WIDE
#endif
