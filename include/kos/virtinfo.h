/* Copyright (c) 2017 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
#ifndef _KOS_VIRTINFO_H
#define _KOS_VIRTINFO_H 1

#include <hybrid/compiler.h>
#include <hybrid/types.h>

DECL_BEGIN

/* Virtual address debug information. */


/* This 'ai_source' information should be merged into human-readable format as follows:
 * >> if (!VIRTINFO_SOURCE_PATH) return "???";
 * >> sep = "/";
 * >> path = "";
 * >> if (VIRTINFO_SOURCE_DRIVE) {
 * >>    path += VIRTINFO_SOURCE_DRIVE+":\\";
 * >>    path += VIRTINFO_SOURCE_PATH.strip("\\/");
 * >>    sep = "\\";
 * >> } else {
 * >>    path += VIRTINFO_SOURCE_PATH.rstrip("\\/");
 * >> }
 * >> if (VIRTINFO_SOURCE_NAME) {
 * >>     path += sep+VIRTINFO_SOURCE_NAME.lstrip("\\/");
 * >>     if (VIRTINFO_SOURCE_EXT) path += "."+VIRTINFO_SOURCE_EXT;
 * >> }
 * >> return path;
 *
 * HINT: 
 *    format_printf() implements an extension that lets you
 *    access virtinfo (both in user-space and within the kernel):
 * some_file.c:
 * 00 >>
 * 01 >> #include <stdio.h>
 * 02 >>
 * 03 >> int foo(void) { return 42; }
 * 04 >>
 * 05 >> int main(int argc, char *argv[]) {
 * 06 >>     // This will print "some_file.c(3,0) : foo : This is foo()\n"
 * 07 >>     printf("%[vinfo:%f(%l,%c) : %n] : This is foo()\n",&foo);
 * 08 >> }
 *
 * NOTE: You are required to build the application with
 *       debug informations enabled for this work (`gcc -g').
 */

struct virtinfo {
 /* NOTE: Any unknown field is set to 0/ZERO/NULL, meaning that
  *       every member should be considered '[valid_if(this != 0)]' */
#define VIRTINFO_SOURCE_DRIVE 0 /*< Drive name of the source file. */
#define VIRTINFO_SOURCE_PATH  1 /*< Source file path name (May already include VIRTINFO_SOURCE_NAME+VIRTINFO_SOURCE_EXT). */
#define VIRTINFO_SOURCE_NAME  2 /*< Source file name (May already include VIRTINFO_SOURCE_EXT). */
#define VIRTINFO_SOURCE_EXT   3 /*< Source file extension. */
 USER char *ai_source[4]; /*< [0..1][4] Source information. */
 USER char *ai_name;      /*< [0..1] Name of the nearest symbol located at 'VIRTINFO_DATA_PREVADDR'. */
 u32        ai_line;      /*< Source line (1-based). */
 u32        ai_column;    /*< Source line column offset (1-based). */
#define VIRTINFO_DATA_SYMADDR  0 /*< (Module-relative) start address of the surrounding/closest symbol. */
#define VIRTINFO_DATA_SYMSIZE  1 /*< Size of the surrounding symbol (in bytes). */
#define VIRTINFO_DATA_PREVADDR 2 /*< [<= mo_virtinfo::addr] (Module-relative) start address of this set of debug information. */
#define VIRTINFO_DATA_NEXTADDR 3 /*< [>= mo_virtinfo::addr] (Module-relative) address for the next set of debug information. */
#define VIRTINFO_DATA_SOURCEID 4 /*< A unique ID that is equal only for code generated by the same source file. (HINT: ZERO is the invalid ID) */
#define VIRTINFO_DATA_FLAGS    5 /*< Set of 'VIRTINFO_FLAG_*' */
#   define VIRTINFO_FLAG_NONE   0x00000000
#   define VIRTINFO_FLAG_STMT   0x00000001 /*< The address is part of statement assembly, rather than that of an expression. */
#   define VIRTINFO_FLAG_BBLOCK 0x00000002 /*< The address is the start of a basic_block. */
#   define VIRTINFO_FLAG_PROLOG 0x00000100 /*< The address is located within an auto-generated function prolog. */
#   define VIRTINFO_FLAG_EPILOG 0x00000400 /*< The address is located within an auto-generated function epilog. */
#   define VIRTINFO_FLAG_VALID  0x80000000 /*< Indicates that this field is implemented. */
#define VIRTINFO_DATA_ISA      4 /*< The type of instruction set found at the given address. (Assume any/default when ZERO)
                                  *  XXX: I couldn't find any actual values for this, but you should now that this is defined by DWARF. */
#define VIRTINFO_DATA_DISC     5 /*< Source location discriminator. */
 uintptr_t  ai_data[16];  /*< Extended information fields (Unknown/unused/reserved fields are set to ZERO). */
 /* Locally buffered data goes here. (Aka. strings pointed to within ai_source, ai_name, etc.) */
};



#define VIRTINFO_NORMAL 0x00000000 /*< Normal address information query. */

#ifndef __KERNEL__

/* Query addr2line-style information about a virtual `addr' in the caller's VM.
 * @ERRNO: ENODATA: No debug information associated with the given address.
 * NOTE: The relation between 'xvirtinfo' and 'xvirtinfo2' is the same as
 *       for 'xfdname' and 'xfdname2', in that 'xvirtinfo()' behaves according
 *       to getcwd()-style semantics by returning allowing you to pass 'NULL,0'
 *       and have the function automatically allocate a buffer of sufficient
 *       size, while 'xvirtinfo2' will only operate on user-provided buffers
 *       and upon success return the number of required buffer bytes. */
__LIBC struct virtinfo *(__LIBCCALL xvirtinfo)(VIRT void *__addr, USER struct virtinfo *__buf, size_t __bufsize, u32 __flags);
__LIBC ssize_t (__LIBCCALL xvirtinfo2)(VIRT void *__addr, USER struct virtinfo *__buf, size_t __bufsize, u32 __flags);

#endif /* !__KERNEL__ */


DECL_END

#endif /* !_KOS_VIRTINFO_H */
